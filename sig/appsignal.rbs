# AppSignal for Ruby gem's main module.
# 
# Provides method to control the AppSignal instrumentation and the system
# agent. Also provides direct access to instrumentation helpers (from
# {Appsignal::Helpers::Instrumentation}) and metrics helpers (from
# {Appsignal::Helpers::Metrics}) for ease of use.
module Appsignal
  extend Appsignal::Helpers::Metrics
  extend Appsignal::Helpers::Instrumentation
  VERSION: String

  # Start the AppSignal integration.
  # 
  # Starts AppSignal with the given configuration. If no configuration is set
  # yet it will try to automatically load the configuration using the
  # environment loaded from environment variables and the currently working
  # directory.
  # 
  # This is not required for the automatic integrations AppSignal offers, but
  # this is required for all non-automatic integrations and pure Ruby
  # applications. For more information, see our [integrations
  # list](https://docs.appsignal.com/ruby/integrations/) and our [Integrating
  # AppSignal](https://docs.appsignal.com/ruby/instrumentation/integrating-appsignal.html)
  # guide.
  # 
  # ```ruby
  # Appsignal.start
  # ```
  # 
  # with custom loaded configuration
  # ```ruby
  # Appsignal.configure(:production) do |config|
  #   config.ignore_actions = ["My action"]
  # end
  # Appsignal.start
  # ```
  def self.start: () -> void

  # Stop AppSignal's agent.
  # 
  # Stops the AppSignal agent. Call this before the end of your program to
  # make sure the agent is stopped as well.
  # 
  # _@param_ `called_by` — Name of the thing that requested the agent to be stopped. Will be used in the AppSignal log file.
  # 
  # ```ruby
  # Appsignal.start
  # # Run your application
  # Appsignal.stop
  # ```
  def self.stop: (?String? called_by) -> void

  # Configure the AppSignal Ruby gem using a DSL.
  # 
  # Pass a block to the configure method to configure the Ruby gem.
  # 
  # Each config option defined in our docs can be fetched, set and modified
  # via a helper method in the given block.
  # 
  # After AppSignal has started using {start}, the configuration can not be
  # modified. Any calls to this helper will be ignored.
  # 
  # This helper should not be used to configure multiple environments, like
  # done in the YAML file. Configure the environment you want active when the
  # application starts.
  # 
  # _@param_ `env_param` — The environment to load.
  # 
  # _@param_ `root_path` — The path to look the `config/appsignal.yml` config file in. Defaults to the current working directory.
  # 
  # Configure AppSignal for the application
  # ```ruby
  # Appsignal.configure do |config|
  #   config.path = "/the/app/path"
  #   config.active = ENV["APP_ACTIVE"] == "true"
  #   config.push_api_key = File.read("appsignal_key.txt").chomp
  #   config.ignore_actions = ENDPOINTS.select { |e| e.public? }.map(&:name)
  #   config.request_headers << "MY_CUSTOM_HEADER"
  # end
  # ```
  # 
  # Configure AppSignal for the application and select the environment
  # ```ruby
  # Appsignal.configure(:production) do |config|
  #   config.active = true
  # end
  # ```
  # 
  # Automatically detects the app environment
  # ```ruby
  # # Tries to determine the app environment automatically from the
  # # environment and the libraries it integrates with.
  # ENV["RACK_ENV"] = "production"
  # 
  # Appsignal.configure do |config|
  #   config.env # => "production"
  # end
  # ```
  # 
  # Calling configure multiple times for different environments resets the configuration
  # ```ruby
  # Appsignal.configure(:development) do |config|
  #   config.ignore_actions = ["My action"]
  # end
  # 
  # Appsignal.configure(:production) do |config|
  #   config.ignore_actions # => []
  # end
  # ```
  # 
  # Load config without a block
  # ```ruby
  # # This will require either ENV vars being set
  # # or the config/appsignal.yml being present
  # Appsignal.configure
  # # Or for the environment given as an argument
  # Appsignal.configure(:production)
  # ```
  # 
  # _@see_ `config`
  # 
  # _@see_ `Config`
  # 
  # _@see_ `https://docs.appsignal.com/ruby/configuration.html` — Configuration guide
  # 
  # _@see_ `https://docs.appsignal.com/ruby/configuration/options.html` — Configuration options
  def self.configure: (?(String | Symbol)? env_param, ?root_path: String?) -> void

  def self.forked: () -> void

  # Load an AppSignal integration.
  # 
  # Load one of the supported integrations via our loader system.
  # This will set config defaults and integratie with the library if
  # AppSignal is active upon start.
  # 
  # _@param_ `integration_name` — Name of the integration to load.
  # 
  # Load Sinatra integrations
  # ```ruby
  # # First load the integration
  # Appsignal.load(:sinatra)
  # # Start AppSignal
  # Appsignal.start
  # ```
  # 
  # Load Sinatra integrations and define custom config
  # ```ruby
  # # First load the integration
  # Appsignal.load(:sinatra)
  # 
  # # Customize config
  # Appsignal.configure do |config|
  #   config.ignore_actions = ["GET /ping"]
  # end
  # 
  # # Start AppSignal
  # Appsignal.start
  # ```
  def self.load: ((String | Symbol) integration_name) -> void

  # Returns if the C-extension was loaded properly.
  # 
  # _@see_ `Extension`
  def self.extension_loaded?: () -> bool

  # Returns if {.start} has been called before with a valid config to start
  # AppSignal.
  # 
  # _@see_ `Extension`
  def self.started?: () -> bool

  # Returns the active state of the AppSignal integration.
  # 
  # Conditions apply for AppSignal to be marked as active:
  # 
  # - There is a config set on the {.config} attribute.
  # - The set config is active {Config.active?}.
  # - The AppSignal Extension is loaded {.extension_loaded?}.
  # 
  # This logic is used within instrument helper such as {.instrument} so it's
  # not necessary to wrap {.instrument} calls with this method.
  # 
  # Do this
  # ```ruby
  # Appsignal.instrument(..) do
  #   # Do this
  # end
  # ```
  # 
  # Don't do this
  # ```ruby
  # if Appsignal.active?
  #   Appsignal.instrument(..) do
  #     # Don't do this
  #   end
  # end
  # ```
  def self.active?: () -> bool

  # Check if the AppSignal Ruby gem has started successfully.
  # 
  # If it has not (yet) started or encountered an error in the
  # `config/appsignal.rb` config file during start up that prevented it from
  # starting, it will raise a {Appsignal::NotStartedError}.
  # 
  # If there an error raised from the config file, it will include it as the
  # error cause of the raised error.
  def self.check_if_started!: () -> void

  # Report a gauge metric.
  # 
  # _@param_ `name` — The name of the metric.
  # 
  # _@param_ `value` — The value of the metric.
  # 
  # _@param_ `tags` — The tags for the metric. The Hash keys can be either a String or a Symbol. The tag values can be a String, Symbol, Integer, Float, TrueClass or FalseClass.
  # 
  # _@see_ `https://docs.appsignal.com/metrics/custom.html` — Metrics documentation
  def self.set_gauge: ((String | Symbol) name, (Integer | Float) value, ?::Hash[String, Object] tags) -> void

  # Report a counter metric.
  # 
  # _@param_ `name` — The name of the metric.
  # 
  # _@param_ `value` — The value of the metric.
  # 
  # _@param_ `tags` — The tags for the metric. The Hash keys can be either a String or a Symbol. The tag values can be a String, Symbol, Integer, Float, TrueClass or FalseClass.
  # 
  # _@see_ `https://docs.appsignal.com/metrics/custom.html` — Metrics documentation
  def self.increment_counter: ((String | Symbol) name, ?(Integer | Float) value, ?::Hash[String, Object] tags) -> void

  # Report a distribution metric.
  # 
  # _@param_ `name` — The name of the metric.
  # 
  # _@param_ `value` — The value of the metric.
  # 
  # _@param_ `tags` — The tags for the metric. The Hash keys can be either a String or a Symbol. The tag values can be a String, Symbol, Integer, Float, TrueClass or FalseClass.
  # 
  # _@see_ `https://docs.appsignal.com/metrics/custom.html` — Metrics documentation
  def self.add_distribution_value: ((String | Symbol) name, (Integer | Float) value, ?::Hash[String, Object] tags) -> void

  # Monitor a block of code with AppSignal.
  # 
  # This is a helper to create an AppSignal transaction, track any errors
  # that may occur and complete the transaction.
  # 
  # This helper is recommended to be used in Ruby scripts and parts of an
  # app not already instrumented by AppSignal's automatic instrumentations.
  # 
  # Use this helper in combination with our {.instrument} helper to track
  # instrumentation events.
  # 
  # If AppSignal is not active ({Appsignal.active?}) it will still execute
  # the block, but not create a transaction for it.
  # 
  # _@param_ `namespace` — The namespace to set on the new transaction. Defaults to the 'web' namespace. This will not update the active transaction's namespace if {.monitor} is called when another transaction is already active.
  # 
  # _@param_ `action` — The action name for the transaction. The action name is required to be set for the transaction to be reported. The argument can be set to `nil` or `:set_later` if the action is set within the block with {#set_action}. This will not update the active transaction's action if {.monitor} is called when another transaction is already active.
  # 
  # _@return_ — The value of the given block is returned.
  # 
  # Instrument a block of code
  # ```ruby
  # Appsignal.monitor(
  #   :namespace => "my_namespace",
  #   :action => "MyClass#my_method"
  # ) do
  #   # Some code
  # end
  # ```
  # 
  # Instrument a block of code using the default namespace
  # ```ruby
  # Appsignal.monitor(
  #   :action => "MyClass#my_method"
  # ) do
  #   # Some code
  # end
  # ```
  # 
  # Instrument a block of code with an instrumentation event
  # ```ruby
  # Appsignal.monitor(
  #   :namespace => "my_namespace",
  #   :action => "MyClass#my_method"
  # ) do
  #   Appsignal.instrument("some_event.some_group") do
  #     # Some code
  #   end
  # end
  # ```
  # 
  # Set the action name in the monitor block
  # ```ruby
  # Appsignal.monitor(
  #   :action => nil
  # ) do
  #   # Some code
  # 
  #   Appsignal.set_action("GET /resource/:id")
  # end
  # ```
  # 
  # Set the action name in the monitor block
  # ```ruby
  # Appsignal.monitor(
  #   :action => :set_later # Explicit placeholder
  # ) do
  #   # Some code
  # 
  #   Appsignal.set_action("GET /resource/:id")
  # end
  # ```
  # 
  # Set custom metadata on the transaction
  # ```ruby
  # Appsignal.monitor(
  #   :namespace => "my_namespace",
  #   :action => "MyClass#my_method"
  # ) do
  #   # Some code
  # 
  #   Appsignal.add_tags(:tag1 => "value1", :tag2 => "value2")
  #   Appsignal.add_params(:param1 => "value1", :param2 => "value2")
  # end
  # ```
  # 
  # Call monitor within monitor will do nothing
  # ```ruby
  # Appsignal.monitor(
  #   :namespace => "my_namespace",
  #   :action => "MyClass#my_method"
  # ) do
  #   # This will _not_ update the namespace and action name
  #   Appsignal.monitor(
  #     :namespace => "my_other_namespace",
  #     :action => "MyOtherClass#my_other_method"
  #   ) do
  #     # Some code
  # 
  #     # The reported namespace will be "my_namespace"
  #     # The reported action will be "MyClass#my_method"
  #   end
  # end
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/background-jobs.html` — Monitor guide
  def self.monitor: (action: (String | Symbol | NilClass), ?namespace: (String | Symbol)?) -> Object

  # Instrument a block of code and stop AppSignal.
  # 
  # Useful for cases such as one-off scripts where there is no long running
  # process active and the data needs to be sent after the process exists.
  # 
  # Acts the same way as {.monitor}. See that method for more
  # documentation.
  # 
  # _@param_ `namespace` — The namespace to set on the new transaction. Defaults to the 'web' namespace. This will not update the active transaction's namespace if {.monitor} is called when another transaction is already active.
  # 
  # _@param_ `action` — The action name for the transaction. The action name is required to be set for the transaction to be reported. The argument can be set to `nil` or `:set_later` if the action is set within the block with {#set_action}. This will not update the active transaction's action if {.monitor} is called when another transaction is already active.
  # 
  # _@return_ — The value of the given block is returned.
  # 
  # _@see_ `monitor`
  def self.monitor_and_stop: (action: (String | Symbol | NilClass), ?namespace: (String | Symbol)?) -> Object

  # Send an error to AppSignal regardless of the context.
  # 
  # **We recommend using the {#report_error} helper instead.**
  # 
  # Records and send the exception to AppSignal.
  # 
  # This instrumentation helper does not require a transaction to be
  # active, it starts a new transaction by itself.
  # 
  # Use {.set_error} if your want to add an exception to the current
  # transaction.
  # 
  # **Note**: Does not do anything if AppSignal is not active or when the
  # "error" is not a class extended from Ruby's Exception class.
  # 
  # _@param_ `error` — The error to send to AppSignal.
  # 
  # Send an exception
  # ```ruby
  # begin
  #   raise "oh no!"
  # rescue => e
  #   Appsignal.send_error(e)
  # end
  # ```
  # 
  # Add more metadata to transaction
  # ```ruby
  # Appsignal.send_error(e) do
  #   Appsignal.set_namespace("my_namespace")
  #   Appsignal.set_action("my_action_name")
  #   Appsignal.add_params(:search_query => params[:search_query])
  #   Appsignal.add_tags(:key => "value")
  # end
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/exception-handling.html` — Exception handling guide
  def self.send_error: (Exception error) ?{ (Transaction transaction) -> void } -> void

  # Set an error on the current transaction.
  # 
  # **We recommend using the {#report_error} helper instead.**
  # 
  # **Note**: Does not do anything if AppSignal is not active, no
  # transaction is currently active or when the "error" is not a class
  # extended from Ruby's Exception class.
  # 
  # _@param_ `exception` — The error to add to the current transaction.
  # 
  # Manual instrumentation of set_error.
  # ```ruby
  # # Manually starting AppSignal here
  # # Manually starting a transaction here.
  # begin
  #   raise "oh no!"
  # rescue => e
  #   Appsignal.set_error(e)
  # end
  # # Manually completing the transaction here.
  # # Manually stopping AppSignal here
  # ```
  # 
  # In a Rails application
  # ```ruby
  # class SomeController < ApplicationController
  #   # The AppSignal transaction is created by our integration for you.
  #   def create
  #     # Do something that breaks
  #   rescue => e
  #     Appsignal.set_error(e)
  #   end
  # end
  # ```
  # 
  # Add more metadata to transaction
  # ```ruby
  # Appsignal.set_error(e) do
  #   Appsignal.set_namespace("my_namespace")
  #   Appsignal.set_action("my_action_name")
  #   Appsignal.add_params(:search_query => params[:search_query])
  #   Appsignal.add_tags(:key => "value")
  # end
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/exception-handling.html` — Exception handling guide
  def self.set_error: (Exception exception) ?{ (Transaction transaction) -> void } -> void

  # Report an error to AppSignal.
  # 
  # If a transaction is currently active, it will report the error on the
  # current transaction. If no transaction is active, it will report the
  # error on a new transaction.
  # 
  # If a transaction is active and the transaction already has an error
  # reported on it, it will report multiple errors, up to a maximum of 10
  # errors.
  # 
  # If a block is given to this method, the metadata set in this block will
  # only be applied to the transaction created for the given error. The
  # block will be called when the transaction is completed, which can be
  # much later than when {#report_error} is called.
  # 
  # **Note**: If AppSignal is not active, no error is reported.
  # 
  # **Note**: If the given exception argument is not an Exception subclass,
  # it will not be reported.
  # 
  # _@param_ `exception` — The error to add to the current transaction.
  # 
  # ```ruby
  # class SomeController < ApplicationController
  #   def create
  #     # Do something that breaks
  #   rescue => error
  #     Appsignal.report_error(error)
  #   end
  # end
  # ```
  # 
  # Add more metadata to transaction
  # ```ruby
  # Appsignal.report_error(error) do
  #   Appsignal.set_namespace("my_namespace")
  #   Appsignal.set_action("my_action_name")
  #   Appsignal.add_params(:search_query => params[:search_query])
  #   Appsignal.add_tags(:key => "value")
  # end
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/exception-handling.html` — Exception handling guide
  def self.report_error: (Exception exception) ?{ (Transaction transaction) -> void } -> void

  # Set a custom action name for the current transaction.
  # 
  # When using an integration such as the Rails or Sinatra AppSignal will
  # try to find the action name from the controller or endpoint for you.
  # 
  # If you want to customize the action name as it appears on AppSignal.com
  # you can use this method. This overrides the action name AppSignal
  # generates in an integration.
  # 
  # _@param_ `action`
  # 
  # in a Rails controller
  # ```ruby
  # class SomeController < ApplicationController
  #   before_action :set_appsignal_action
  # 
  #   def set_appsignal_action
  #     Appsignal.set_action("DynamicController#dynamic_method")
  #   end
  # end
  # ```
  def self.set_action: (String action) -> void

  # Set a custom namespace for the current transaction.
  # 
  # When using an integration such as Rails or Sidekiq AppSignal will try
  # to find a appropriate namespace for the transaction.
  # 
  # A Rails controller will be automatically put in the "http_request"
  # namespace, while a Sidekiq background job is put in the
  # "background_job" namespace.
  # 
  # Note: The "http_request" namespace gets transformed on AppSignal.com to
  # "Web" and "background_job" gets transformed to "Background".
  # 
  # If you want to customize the namespace in which transactions appear you
  # can use this method. This overrides the namespace AppSignal uses by
  # default.
  # 
  # A common request we've seen is to split the administration panel from
  # the main application.
  # 
  # _@param_ `namespace`
  # 
  # create a custom admin namespace
  # ```ruby
  # class AdminController < ApplicationController
  #   before_action :set_appsignal_namespace
  # 
  #   def set_appsignal_namespace
  #     Appsignal.set_namespace("admin")
  #   end
  # end
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/guides/namespaces.html` — Grouping with namespaces guide
  def self.set_namespace: (String namespace) -> void

  # Add custom data to the current transaction.
  # 
  # Add extra information about the request or background that cannot be
  # expressed in tags, like nested data structures.
  # 
  # If the root data type changes between calls of this method, the last
  # method call is stored.
  # 
  # _@param_ `data` — Custom data to add to the transaction.
  # 
  # Add Hash data
  # ```ruby
  # Appsignal.add_custom_data(:user => { :locale => "en" })
  # ```
  # 
  # Merges Hash data
  # ```ruby
  # Appsignal.add_custom_data(:abc => "def")
  # Appsignal.add_custom_data(:xyz => "...")
  # # The custom data is: { :abc => "def", :xyz => "..." }
  # ```
  # 
  # Add Array data
  # ```ruby
  # Appsignal.add_custom_data([
  #   "array with data",
  #   "other value",
  #   :options => { :verbose => true }
  # ])
  # ```
  # 
  # Merges Array data
  # ```ruby
  # Appsignal.add_custom_data([1, 2, 3])
  # Appsignal.add_custom_data([4, 5, 6])
  # # The custom data is: [1, 2, 3, 4, 5, 6]
  # ```
  # 
  # Mixing of root data types is not supported
  # ```ruby
  # Appsignal.add_custom_data(:abc => "def")
  # Appsignal.add_custom_data([1, 2, 3])
  # # The custom data is: [1, 2, 3]
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
  def self.add_custom_data: ((::Hash[Object, Object] | ::Array[Object]) data) -> void

  # Add tags to the current transaction.
  # 
  # Tags are extra bits of information that are added to transaction and
  # appear on sample details pages on AppSignal.com.
  # 
  # When this method is called multiple times, it will merge the tags.
  # 
  # _@param_ `tags` — Collection of tags to add to the transaction.
  # 
  # ```ruby
  # Appsignal.add_tags(:locale => "en", :user_id => 1)
  # Appsignal.add_tags("locale" => "en")
  # Appsignal.add_tags("user_id" => 1)
  # ```
  # 
  # Nested hashes are not supported
  # ```ruby
  # # Bad
  # Appsignal.add_tags(:user => { :locale => "en" })
  # ```
  # 
  # in a Rails controller
  # ```ruby
  # class SomeController < ApplicationController
  #   before_action :add_appsignal_tags
  # 
  #   def add_appsignal_tags
  #     Appsignal.add_tags(:locale => I18n.locale)
  #   end
  # end
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/tagging.html` — Tagging guide
  def self.add_tags: (?::Hash[Object, Object] tags) -> void

  # Add parameters to the current transaction.
  # 
  # Parameters are automatically added by most of our integrations. It
  # should not be necessary to call this method unless you want to report
  # different parameters.
  # 
  # To filter parameters, see our parameter filtering guide.
  # 
  # When both the `params` argument and a block is given to this method,
  # the block is leading and the argument will _not_ be used.
  # 
  # _@param_ `params` — The parameters to add to the transaction.
  # 
  # Add parameters
  # ```ruby
  # Appsignal.add_params("param1" => "value1")
  # # The parameters include: { "param1" => "value1" }
  # ```
  # 
  # Calling `add_params` multiple times will merge the values
  # ```ruby
  # Appsignal.add_params("param1" => "value1")
  # Appsignal.add_params("param2" => "value2")
  # # The parameters include:
  # # { "param1" => "value1", "param2" => "value2" }
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
  # 
  # _@see_ `https://docs.appsignal.com/guides/filter-data/filter-parameters.html` — Parameter filtering guide
  def self.add_params: (?::Hash[untyped, untyped]? params) -> void

  # Mark the parameters sample data to be set as an empty value.
  # 
  # Use this helper to unset request parameters / background job arguments
  # and not report any for this transaction.
  # 
  # If parameters would normally be added by AppSignal instrumentations of
  # libraries, these parameters will not be added to the Transaction.
  # 
  # Calling {#add_params} after this helper will add new parameters to the
  # transaction.
  # 
  # _@see_ `Transaction#set_empty_params!`
  # 
  # _@see_ `Transaction#set_params_if_nil`
  def self.set_empty_params!: () -> void

  # Add session data to the current transaction.
  # 
  # Session data is automatically added by most of our integrations. It
  # should not be necessary to call this method unless you want to report
  # different session data.
  # 
  # To filter session data, see our session data filtering guide.
  # 
  # When both the `session_data` argument and a block is given to this
  # method, the bock is leading and the argument will _not_ be used.
  # 
  # _@param_ `session_data` — The session data to add to the transaction.
  # 
  # Add session data
  # ```ruby
  # Appsignal.add_session_data("session" => "data")
  # # The session data will include:
  # # { "session" => "data" }
  # ```
  # 
  # Calling `add_session_data` multiple times merge the values
  # ```ruby
  # Appsignal.add_session_data("session" => "data")
  # Appsignal.add_session_data("other" => "value")
  # # The session data will include:
  # # { "session" => "data", "other" => "value" }
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
  # 
  # _@see_ `https://docs.appsignal.com/guides/filter-data/filter-session-data.html` — Session data filtering guide
  def self.add_session_data: (?::Hash[untyped, untyped]? session_data) -> void

  # Add request headers to the current transaction.
  # 
  # Request headers are automatically added by most of our integrations. It
  # should not be necessary to call this method unless you want to also
  # report different request headers.
  # 
  # To filter request headers, see our request header filtering guide.
  # 
  # When both the `request_headers` argument and a block is given to this
  # method, the block is leading and the argument will _not_ be used.
  # 
  # _@param_ `headers` — The request headers to add to the transaction.
  # 
  # Add request headers
  # ```ruby
  # Appsignal.add_headers("PATH_INFO" => "/some-path")
  # # The request headers will include:
  # # { "PATH_INFO" => "/some-path" }
  # ```
  # 
  # Calling `add_headers` multiple times merge the values
  # ```ruby
  # Appsignal.add_headers("PATH_INFO" => "/some-path")
  # Appsignal.add_headers("HTTP_USER_AGENT" => "Firefox")
  # # The request headers will include:
  # # { "PATH_INFO" => "/some-path", "HTTP_USER_AGENT" => "Firefox" }
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
  # 
  # _@see_ `https://docs.appsignal.com/guides/filter-data/filter-headers.html` — Request headers filtering guide
  def self.add_headers: (?::Hash[untyped, untyped]? headers) -> void

  # Add breadcrumbs to the transaction.
  # 
  # Breadcrumbs can be used to trace what path a user has taken
  # before encountering an error.
  # 
  # Only the last 20 added breadcrumbs will be saved.
  # 
  # _@param_ `category` — category of breadcrumb e.g. "UI", "Network", "Navigation", "Console".
  # 
  # _@param_ `action` — name of breadcrumb e.g "The user clicked a button", "HTTP 500 from http://blablabla.com"
  # 
  # ```ruby
  # Appsignal.add_breadcrumb(
  #   "Navigation",
  #   "http://blablabla.com",
  #   "",
  #   { :response => 200 },
  #   Time.now.utc
  # )
  # Appsignal.add_breadcrumb(
  #   "Network",
  #   "[GET] http://blablabla.com",
  #   "",
  #   { :response => 500 }
  # )
  # Appsignal.add_breadcrumb(
  #   "UI",
  #   "closed modal(change_password)",
  #   "User closed modal without actions"
  # )
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/breadcrumbs.html` — Breadcrumb reference
  def self.add_breadcrumb: (
                             String category,
                             String action,
                             ?::Hash[untyped, untyped] message,
                             ?::Hash[untyped, untyped] metadata,
                             ?::Hash[untyped, untyped] time
                           ) -> void

  # Instrument helper for AppSignal.
  # 
  # For more help, read our custom instrumentation guide, listed under "See
  # also".
  # 
  # _@param_ `name` — Name of the instrumented event. Read our event naming guide listed under "See also".
  # 
  # _@param_ `title` — Human readable name of the event.
  # 
  # _@param_ `body` — Value of importance for the event, such as the server against an API call is made.
  # 
  # _@param_ `body_format` — Enum for the type of event that is instrumented. Accepted values are {EventFormatter::DEFAULT} and {EventFormatter::SQL_BODY_FORMAT}, but we recommend you use {.instrument_sql} instead of {EventFormatter::SQL_BODY_FORMAT}.
  # 
  # _@return_ — Returns the block's return value.
  # 
  # Simple instrumentation
  # ```ruby
  # Appsignal.instrument("fetch.issue_fetcher") do
  #   # To be instrumented code
  # end
  # ```
  # 
  # Instrumentation with title and body
  # ```ruby
  # Appsignal.instrument(
  #   "fetch.issue_fetcher",
  #   "Fetching issue",
  #   "GitHub API"
  # ) do
  #   # To be instrumented code
  # end
  # ```
  # 
  # _@see_ `.instrument_sql`
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/instrumentation.html` — AppSignal custom instrumentation guide
  # 
  # _@see_ `https://docs.appsignal.com/api/event-names.html` — AppSignal event naming guide
  def self.instrument: (
                         String name,
                         ?String? title,
                         ?String? body,
                         ?Integer body_format
                       ) -> Object

  # Instrumentation helper for SQL queries.
  # 
  # This helper filters out values from SQL queries so you don't have to.
  # 
  # _@param_ `name` — Name of the instrumented event. Read our event naming guide listed under "See also".
  # 
  # _@param_ `title` — Human readable name of the event.
  # 
  # _@param_ `body` — SQL query that's being executed.
  # 
  # _@return_ — Returns the block's return value.
  # 
  # SQL query instrumentation
  # ```ruby
  # body = "SELECT * FROM ..."
  # Appsignal.instrument_sql("perform.query", nil, body) do
  #   # To be instrumented code
  # end
  # ```
  # 
  # SQL query instrumentation
  # ```ruby
  # body = "WHERE email = 'foo@..'"
  # Appsignal.instrument_sql("perform.query", nil, body) do
  #   # query value will replace 'foo..' with a question mark `?`.
  # end
  # ```
  # 
  # _@see_ `.instrument`
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/instrumentation.html` — AppSignal custom instrumentation guide
  # 
  # _@see_ `https://docs.appsignal.com/api/event-names.html` — AppSignal event naming guide
  def self.instrument_sql: (String name, ?String? title, ?String? body) -> Object

  # Convenience method for ignoring instrumentation events in a block of
  # code.
  # 
  # - This helper ignores events, like those created
  #   `Appsignal.instrument`, within this block.
  #   This includes custom instrumentation and events recorded by AppSignal
  #   integrations for requests, database queries, view rendering, etc.
  # - The time spent in the block is still reported on the transaction.
  # - Errors and metrics are reported from within this block.
  # 
  # _@return_ — Returns the return value of the block.
  # 
  # ```ruby
  # Appsignal.instrument "my_event.my_group" do
  #   # Complex code here
  # end
  # Appsignal.ignore_instrumentation_events do
  #   Appsignal.instrument "my_ignored_event.my_ignored_group" do
  #     # Complex code here
  #   end
  # end
  # 
  # # Only the "my_event.my_group" instrumentation event is reported.
  # ```
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/ignore-instrumentation.html` — Ignore instrumentation guide
  def self.ignore_instrumentation_events: () -> Object

  # The loaded AppSignal configuration.
  # Returns the current AppSignal configuration.
  # 
  # Can return `nil` if no configuration has been set or automatically loaded
  # by an automatic integration or by calling {.start}.
  # 
  # ```ruby
  # Appsignal.config
  # ```
  # 
  # _@see_ `configure`
  # 
  # _@see_ `Config`
  def self.config: () -> Config?

  # Returns the error that was encountered while loading the `appsignal.rb`
  # config file.
  # 
  # It does not include any error that occurred while loading the
  # `appsignal.yml` file.
  # 
  # If the value is `nil`, no error was encountered or AppSignal wasn't
  # started yet.
  def self.config_error: () -> Exception?

  # {Appsignal::Demo} is a way to send demonstration / test samples for a
  # exception and a performance issue.
  # 
  # @example Send example transactions
  #   Appsignal::Demo.transmit
  # 
  # @since 2.0.0
  # @see Appsignal::CLI::Demo
  # @api private
  class Demo
    # Starts AppSignal and transmits the demonstration samples to AppSignal
    # using the loaded configuration.
    # 
    # _@return_ — - returns `false` if Appsignal is not active.
    def self.transmit: () -> bool

    # Error type used to create demonstration exception.
    class TestError < StandardError
    end
  end

  class Config
    # Check if the configuration is valid.
    # 
    # _@return_ — True if the configuration is valid, false otherwise.
    def valid?: () -> bool

    # Check if AppSignal is active for the current environment.
    # 
    # _@return_ — True if active for the current environment.
    def active_for_env?: () -> bool

    # Check if AppSignal is active.
    # 
    # _@return_ — True if valid and active for the current environment.
    def active?: () -> bool

    def yml_config_file?: () -> bool
  end

  # Logger that flushes logs to the AppSignal logging service.
  # 
  # @see https://docs.appsignal.com/logging/platforms/integrations/ruby.html
  #   AppSignal Ruby logging documentation.
  class Logger < ::Logger
    # Create a new logger instance
    # 
    # _@param_ `group` — Name of the group for this logger.
    # 
    # _@param_ `level` — Minimum log level to report. Log lines below this level will be ignored.
    # 
    # _@param_ `format` — Format to use to parse log line attributes.
    # 
    # _@param_ `attributes` — Default attributes for all log lines.
    def initialize: (
                      untyped group,
                      ?level: untyped,
                      ?format: untyped,
                      ?attributes: untyped
                    ) -> void

    # Sets the formatter for this logger and all broadcasted loggers.
    # 
    # _@param_ `formatter` — The formatter to use for log messages.
    def formatter=: (Proc formatter) -> Proc

    # Log a debug level message
    # 
    # _@param_ `message` — Message to log
    # 
    # _@param_ `attributes` — Attributes to tag the log with
    def debug: (?untyped message, ?untyped attributes) -> void

    # Log an info level message
    # 
    # _@param_ `message` — Message to log
    # 
    # _@param_ `attributes` — Attributes to tag the log with
    def info: (?untyped message, ?untyped attributes) -> void

    # Log a warn level message
    # 
    # _@param_ `message` — Message to log
    # 
    # _@param_ `attributes` — Attributes to tag the log with
    def warn: (?untyped message, ?untyped attributes) -> void

    # Log an error level message
    # 
    # _@param_ `message` — Message to log
    # 
    # _@param_ `attributes` — Attributes to tag the log with
    def error: (?untyped message, ?untyped attributes) -> void

    # Log a fatal level message
    # 
    # _@param_ `message` — Message to log
    # 
    # _@param_ `attributes` — Attributes to tag the log with
    def fatal: (?untyped message, ?untyped attributes) -> void

    # Log an info level message
    # 
    # Returns the number of characters written.
    # 
    # _@param_ `message` — Message to log
    def <<: (untyped message) -> Integer

    # Temporarily silences the logger to a specified level while executing a block.
    # 
    # When using ActiveSupport::TaggedLogging without the broadcast feature,
    # the passed logger is required to respond to the `silence` method.
    # 
    # Reference links:
    # 
    # - https://github.com/rails/rails/blob/e11ebc04cfbe41c06cdfb70ee5a9fdbbd98bb263/activesupport/lib/active_support/logger.rb#L60-L76
    # - https://github.com/rails/rails/blob/e11ebc04cfbe41c06cdfb70ee5a9fdbbd98bb263/activesupport/lib/active_support/logger_silence.rb
    # 
    # _@param_ `severity` — The minimum severity level to log during the block.
    # 
    # _@return_ — The return value of the block.
    def silence: (?Integer severity) -> Object

    # Adds a logger to broadcast log messages to.
    # 
    # _@param_ `logger` — The logger to add to the broadcast list.
    def broadcast_to: (Logger logger) -> ::Array[Logger]

    # Logging severity threshold
    attr_reader level: Integer
  end

  module Probes
    # Register a new minutely probe.
    # 
    # Supported probe types are:
    # 
    # - Lambda - A lambda is an object that listens to a `call` method call.
    #   This `call` method is called every minute.
    # - Class - A class object is an object that listens to a `new` and
    #   `call` method call. The `new` method is called when the minutely
    #   probe thread is started to initialize all probes. This allows probes
    #   to load dependencies once beforehand. Their `call` method is called
    #   every minute.
    # - Class instance - A class instance object is an object that listens to
    #   a `call` method call. The `call` method is called every minute.
    # 
    # _@param_ `name` — Name of the probe. Can be used with {ProbeCollection#[]}. This name will be used in errors in the log and allows overwriting of probes by registering new ones with the same name.
    # 
    # _@param_ `probe` — Any object that listens to the `call` method will be used as a probe.
    # 
    # Register a new probe
    # ```ruby
    # Appsignal::Probes.register :my_probe, lambda {}
    # ```
    # 
    # Overwrite an existing registered probe
    # ```ruby
    # Appsignal::Probes.register :my_probe, lambda {}
    # Appsignal::Probes.register :my_probe, lambda { puts "hello" }
    # ```
    # 
    # Add a lambda as a probe
    # ```ruby
    # Appsignal::Probes.register :my_probe, lambda { puts "hello" }
    # # "hello" # printed every minute
    # ```
    # 
    # Add a probe instance
    # ```ruby
    # class MyProbe
    #   def initialize
    #     puts "started"
    #   end
    # 
    #   def call
    #     puts "called"
    #   end
    # end
    # 
    # Appsignal::Probes.register :my_probe, MyProbe.new
    # # "started" # printed immediately
    # # "called" # printed every minute
    # ```
    # 
    # Add a probe class
    # ```ruby
    # class MyProbe
    #   def initialize
    #     # Add things that only need to be done on start up for this probe
    #     require "some/library/dependency"
    #     @cache = {} # initialize a local cache variable
    #     puts "started"
    #   end
    # 
    #   def call
    #     puts "called"
    #   end
    # end
    # 
    # Appsignal::Probes.register :my_probe, MyProbe
    # Appsignal::Probes.start # This is called for you
    # # "started" # Printed on Appsignal::Probes.start
    # # "called" # Repeated every minute
    # ```
    def self.register: ((Symbol | String) name, Object probe) -> void

    # Unregister a probe that's registered with {register}.
    # Can also be used to unregister automatically registered probes by the
    # gem.
    # 
    # _@param_ `name` — Name of the probe used to {register} the probe.
    # 
    # Unregister probes
    # ```ruby
    # # First register a probe
    # Appsignal::Probes.register :my_probe, lambda {}
    # 
    # # Then unregister a probe if needed
    # Appsignal::Probes.unregister :my_probe
    # ```
    def self.unregister: ((Symbol | String) name) -> void

    def self.start: () -> void

    # Returns if the probes thread has been started. If the value is false or
    # nil, it has not been started yet.
    def self.started?: () -> bool?

    # Stop the minutely probes mechanism. Stop the thread and clear all probe
    # instances.
    def self.stop: () -> void
  end

  module CheckIn
    # Track cron check-ins.
    # 
    # Track the execution of scheduled processes by sending a cron check-in.
    # 
    # To track the duration of a piece of code, pass a block to {.cron}
    # to report both when the process starts, and when it finishes.
    # 
    # If an exception is raised within the block, the finish event will not
    # be reported, triggering a notification about the missing cron check-in.
    # The exception will bubble outside of the cron check-in block.
    # 
    # _@param_ `identifier` — identifier of the cron check-in to report.
    # 
    # Send a cron check-in
    # ```ruby
    # Appsignal::CheckIn.cron("send_invoices")
    # ```
    # 
    # Send a cron check-in with duration
    # ```ruby
    # Appsignal::CheckIn.cron("send_invoices") do
    #   # your code
    # end
    # ```
    # 
    # _@see_ `https://docs.appsignal.com/check-ins/cron`
    def self.cron: (String identifier) -> void

    # Track heartbeat check-ins.
    # 
    # Track the execution of long-lived processes by sending a heartbeat
    # check-in.
    # 
    # _@param_ `identifier` — identifier of the heartbeat check-in to report.
    # 
    # _@param_ `continuous` — whether the heartbeats should be sent continuously during the lifetime of the process. Defaults to `false`.
    # 
    # Send a heartbeat check-in
    # ```ruby
    # Appsignal::CheckIn.heartbeat("main_loop")
    # ```
    # 
    # _@see_ `https://docs.appsignal.com/check-ins/heartbeat`
    def self.heartbeat: (String identifier, ?continuous: bool) -> void
  end

  class Transaction
    HTTP_REQUEST: String
    BACKGROUND_JOB: String

    # Create a new transaction and set it as the currently active
    # transaction.
    # 
    # _@param_ `namespace` — Namespace of the to be created transaction.
    def self.create: (String namespace) -> Transaction

    # Returns currently active transaction or a {NilTransaction} if none is
    # active.
    # 
    # _@see_ `.current?`
    def self.current: () -> bool

    # Returns if any transaction is currently active or not. A
    # {NilTransaction} is not considered an active transaction.
    # 
    # _@see_ `.current`
    def self.current?: () -> bool

    # Complete the currently active transaction and unset it as the active
    # transaction.
    def self.complete_current!: () -> void

    # Add parameters to the transaction.
    # 
    # When this method is called multiple times, it will merge the request parameters.
    # 
    # When both the `given_params` and a block is given to this method, the
    # block is leading and the argument will _not_ be used.
    # 
    # _@param_ `given_params` — The parameters to set on the transaction.
    # 
    # _@see_ `Helpers::Instrumentation#add_params`
    # 
    # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
    def add_params: (?::Hash[untyped, untyped]? given_params) -> void

    # Add tags to the transaction.
    # 
    # When this method is called multiple times, it will merge the tags.
    # 
    # _@param_ `given_tags` — Collection of tags.
    # 
    # _@see_ `Helpers::Instrumentation#add_tags`
    # 
    # _@see_ `https://docs.appsignal.com/ruby/instrumentation/tagging.html` — Tagging guide
    def add_tags: (?::Hash[untyped, untyped] given_tags) -> void

    # Add session data to the transaction.
    # 
    # When this method is called multiple times, it will merge the session data.
    # 
    # When both the `given_session_data` and a block is given to this method,
    # the block is leading and the argument will _not_ be used.
    # 
    # _@param_ `given_session_data` — A hash containing session data.
    # 
    # _@see_ `Helpers::Instrumentation#add_session_data`
    # 
    # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
    def add_session_data: (?::Hash[untyped, untyped]? given_session_data) -> void

    # Add headers to the transaction.
    # 
    # _@param_ `given_headers` — A hash containing headers.
    # 
    # _@see_ `Helpers::Instrumentation#add_headers`
    # 
    # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
    def add_headers: (?::Hash[untyped, untyped]? given_headers) -> void

    # Add custom data to the transaction.
    # 
    # _@param_ `data`
    # 
    # _@see_ `Helpers::Instrumentation#add_custom_data`
    # 
    # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
    def add_custom_data: ((::Hash[untyped, untyped] | ::Array[untyped]) data) -> void

    # Add breadcrumbs to the transaction.
    # 
    # _@param_ `category` — category of breadcrumb e.g. "UI", "Network", "Navigation", "Console".
    # 
    # _@param_ `action` — name of breadcrumb e.g "The user clicked a button", "HTTP 500 from http://blablabla.com"
    # 
    # _@see_ `Appsignal.add_breadcrumb`
    # 
    # _@see_ `https://docs.appsignal.com/ruby/instrumentation/breadcrumbs.html` — Breadcrumb reference
    def add_breadcrumb: (
                          String category,
                          String action,
                          ?::Hash[untyped, untyped] message,
                          ?::Hash[untyped, untyped] metadata,
                          ?::Hash[untyped, untyped] time
                        ) -> void

    # Set an action name for the transaction.
    # 
    # An action name is used to identify the location of a certain sample;
    # error and performance issues.
    # 
    # _@param_ `action` — the action name to set.
    # 
    # _@see_ `Appsignal::Helpers::Instrumentation#set_action`
    def set_action: (String action) -> void

    # Set the namespace for this transaction.
    # 
    # Useful to split up parts of an application into certain namespaces. For
    # example: http requests, background jobs and administration panel
    # controllers.
    # 
    # Note: The "http_request" namespace gets transformed on AppSignal.com to
    # "Web" and "background_job" gets transformed to "Background".
    # 
    # _@param_ `namespace` — namespace name to use for this transaction.
    # 
    # ```ruby
    # transaction.set_namespace("background")
    # ```
    # 
    # _@see_ `Appsignal::Helpers::Instrumentation#set_namespace`
    # 
    # _@see_ `https://docs.appsignal.com/guides/namespaces.html` — Grouping with namespaces guide
    def set_namespace: (String namespace) -> void

    # Set queue start time for transaction.
    # 
    # _@param_ `start` — Queue start time in milliseconds.
    def set_queue_start: (Integer start) -> void
  end

  # Custom markers are used on AppSignal.com to indicate events in an
  # application, to give additional context on graph timelines.
  # 
  # This helper class will send a request to the AppSignal public endpoint to
  # create a Custom marker for the application on AppSignal.com.
  # 
  # @see https://docs.appsignal.com/api/public-endpoint/custom-markers.html
  #   Public Endpoint API markers endpoint documentation
  # @see https://docs.appsignal.com/appsignal/terminology.html#markers
  #   Terminology: Markers
  class CustomMarker
    # _@param_ `icon` — icon to use for the marker, like an emoji.
    # 
    # _@param_ `message` — name of the user that is creating the marker.
    # 
    # _@param_ `created_at` — A Ruby time object or a valid ISO8601 timestamp.
    def self.report: (?icon: String?, ?message: String?, ?created_at: (Time | String)?) -> bool
  end

  # Keeps track of formatters for types event that we can use to get
  # the title and body of an event. Formatters should inherit from this class
  # and implement a format(payload) method which returns an array with the title
  # and body.
  # 
  # When implementing a formatter remember that it cannot keep separate state per
  # event, the same object will be called intermittently in a threaded environment.
  # So only keep global configuration as state and pass the payload around as an
  # argument if you need to use helper methods.
  class EventFormatter
    DEFAULT: Integer
    SQL_BODY_FORMAT: Integer

    # Registers an event formatter for a specific event name.
    # 
    # _@param_ `name` — The name of the event to register the formatter for.
    # 
    # _@param_ `formatter` — The formatter class that implements the `format(payload)` method.
    # 
    # Register a custom formatter
    # ```ruby
    # class CustomFormatter < Appsignal::EventFormatter
    #   def format(payload)
    #     ["Custom event", payload[:body]]
    #   end
    # end
    # 
    # Appsignal::EventFormatter.register("my.event", CustomFormatter)
    # ```
    # 
    # _@see_ `#unregister`
    # 
    # _@see_ `#registered?`
    def self.register: ((String | Symbol) name, ?Class? formatter) -> void

    # Unregisters an event formatter for a specific event name.
    # 
    # _@param_ `name` — The name of the event to unregister the formatter for.
    # 
    # _@param_ `formatter` — The formatter class to unregister. Defaults to `self`.
    # 
    # Unregister a custom formatter
    # ```ruby
    # Appsignal::EventFormatter.unregister("my.event", CustomFormatter)
    # ```
    # 
    # _@see_ `#register`
    # 
    # _@see_ `#registered?`
    def self.unregister: ((String | Symbol) name, ?Class formatter) -> void

    # Checks if an event formatter is registered for a specific event name.
    # 
    # _@param_ `name` — The name of the event to check.
    # 
    # _@param_ `klass` — The specific formatter class to check for. Optional.
    # 
    # _@return_ — true if a formatter is registered, false otherwise.
    # 
    # _@see_ `#register`
    # 
    # _@see_ `#unregister`
    def self.registered?: ((String | Symbol) name, ?Class? klass) -> bool
  end

  module Helpers
    module Metrics
      # Report a gauge metric.
      # 
      # _@param_ `name` — The name of the metric.
      # 
      # _@param_ `value` — The value of the metric.
      # 
      # _@param_ `tags` — The tags for the metric. The Hash keys can be either a String or a Symbol. The tag values can be a String, Symbol, Integer, Float, TrueClass or FalseClass.
      # 
      # _@see_ `https://docs.appsignal.com/metrics/custom.html` — Metrics documentation
      def set_gauge: ((String | Symbol) name, (Integer | Float) value, ?::Hash[String, Object] tags) -> void

      # Report a counter metric.
      # 
      # _@param_ `name` — The name of the metric.
      # 
      # _@param_ `value` — The value of the metric.
      # 
      # _@param_ `tags` — The tags for the metric. The Hash keys can be either a String or a Symbol. The tag values can be a String, Symbol, Integer, Float, TrueClass or FalseClass.
      # 
      # _@see_ `https://docs.appsignal.com/metrics/custom.html` — Metrics documentation
      def increment_counter: ((String | Symbol) name, ?(Integer | Float) value, ?::Hash[String, Object] tags) -> void

      # Report a distribution metric.
      # 
      # _@param_ `name` — The name of the metric.
      # 
      # _@param_ `value` — The value of the metric.
      # 
      # _@param_ `tags` — The tags for the metric. The Hash keys can be either a String or a Symbol. The tag values can be a String, Symbol, Integer, Float, TrueClass or FalseClass.
      # 
      # _@see_ `https://docs.appsignal.com/metrics/custom.html` — Metrics documentation
      def add_distribution_value: ((String | Symbol) name, (Integer | Float) value, ?::Hash[String, Object] tags) -> void
    end

    module Instrumentation
      # Monitor a block of code with AppSignal.
      # 
      # This is a helper to create an AppSignal transaction, track any errors
      # that may occur and complete the transaction.
      # 
      # This helper is recommended to be used in Ruby scripts and parts of an
      # app not already instrumented by AppSignal's automatic instrumentations.
      # 
      # Use this helper in combination with our {.instrument} helper to track
      # instrumentation events.
      # 
      # If AppSignal is not active ({Appsignal.active?}) it will still execute
      # the block, but not create a transaction for it.
      # 
      # _@param_ `namespace` — The namespace to set on the new transaction. Defaults to the 'web' namespace. This will not update the active transaction's namespace if {.monitor} is called when another transaction is already active.
      # 
      # _@param_ `action` — The action name for the transaction. The action name is required to be set for the transaction to be reported. The argument can be set to `nil` or `:set_later` if the action is set within the block with {#set_action}. This will not update the active transaction's action if {.monitor} is called when another transaction is already active.
      # 
      # _@return_ — The value of the given block is returned.
      # 
      # Instrument a block of code
      # ```ruby
      # Appsignal.monitor(
      #   :namespace => "my_namespace",
      #   :action => "MyClass#my_method"
      # ) do
      #   # Some code
      # end
      # ```
      # 
      # Instrument a block of code using the default namespace
      # ```ruby
      # Appsignal.monitor(
      #   :action => "MyClass#my_method"
      # ) do
      #   # Some code
      # end
      # ```
      # 
      # Instrument a block of code with an instrumentation event
      # ```ruby
      # Appsignal.monitor(
      #   :namespace => "my_namespace",
      #   :action => "MyClass#my_method"
      # ) do
      #   Appsignal.instrument("some_event.some_group") do
      #     # Some code
      #   end
      # end
      # ```
      # 
      # Set the action name in the monitor block
      # ```ruby
      # Appsignal.monitor(
      #   :action => nil
      # ) do
      #   # Some code
      # 
      #   Appsignal.set_action("GET /resource/:id")
      # end
      # ```
      # 
      # Set the action name in the monitor block
      # ```ruby
      # Appsignal.monitor(
      #   :action => :set_later # Explicit placeholder
      # ) do
      #   # Some code
      # 
      #   Appsignal.set_action("GET /resource/:id")
      # end
      # ```
      # 
      # Set custom metadata on the transaction
      # ```ruby
      # Appsignal.monitor(
      #   :namespace => "my_namespace",
      #   :action => "MyClass#my_method"
      # ) do
      #   # Some code
      # 
      #   Appsignal.add_tags(:tag1 => "value1", :tag2 => "value2")
      #   Appsignal.add_params(:param1 => "value1", :param2 => "value2")
      # end
      # ```
      # 
      # Call monitor within monitor will do nothing
      # ```ruby
      # Appsignal.monitor(
      #   :namespace => "my_namespace",
      #   :action => "MyClass#my_method"
      # ) do
      #   # This will _not_ update the namespace and action name
      #   Appsignal.monitor(
      #     :namespace => "my_other_namespace",
      #     :action => "MyOtherClass#my_other_method"
      #   ) do
      #     # Some code
      # 
      #     # The reported namespace will be "my_namespace"
      #     # The reported action will be "MyClass#my_method"
      #   end
      # end
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/ruby/instrumentation/background-jobs.html` — Monitor guide
      def monitor: (action: (String | Symbol | NilClass), ?namespace: (String | Symbol)?) -> Object

      # Instrument a block of code and stop AppSignal.
      # 
      # Useful for cases such as one-off scripts where there is no long running
      # process active and the data needs to be sent after the process exists.
      # 
      # Acts the same way as {.monitor}. See that method for more
      # documentation.
      # 
      # _@param_ `namespace` — The namespace to set on the new transaction. Defaults to the 'web' namespace. This will not update the active transaction's namespace if {.monitor} is called when another transaction is already active.
      # 
      # _@param_ `action` — The action name for the transaction. The action name is required to be set for the transaction to be reported. The argument can be set to `nil` or `:set_later` if the action is set within the block with {#set_action}. This will not update the active transaction's action if {.monitor} is called when another transaction is already active.
      # 
      # _@return_ — The value of the given block is returned.
      # 
      # _@see_ `monitor`
      def monitor_and_stop: (action: (String | Symbol | NilClass), ?namespace: (String | Symbol)?) -> Object

      # Send an error to AppSignal regardless of the context.
      # 
      # **We recommend using the {#report_error} helper instead.**
      # 
      # Records and send the exception to AppSignal.
      # 
      # This instrumentation helper does not require a transaction to be
      # active, it starts a new transaction by itself.
      # 
      # Use {.set_error} if your want to add an exception to the current
      # transaction.
      # 
      # **Note**: Does not do anything if AppSignal is not active or when the
      # "error" is not a class extended from Ruby's Exception class.
      # 
      # _@param_ `error` — The error to send to AppSignal.
      # 
      # Send an exception
      # ```ruby
      # begin
      #   raise "oh no!"
      # rescue => e
      #   Appsignal.send_error(e)
      # end
      # ```
      # 
      # Add more metadata to transaction
      # ```ruby
      # Appsignal.send_error(e) do
      #   Appsignal.set_namespace("my_namespace")
      #   Appsignal.set_action("my_action_name")
      #   Appsignal.add_params(:search_query => params[:search_query])
      #   Appsignal.add_tags(:key => "value")
      # end
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/ruby/instrumentation/exception-handling.html` — Exception handling guide
      def send_error: (Exception error) ?{ (Transaction transaction) -> void } -> void

      # Set an error on the current transaction.
      # 
      # **We recommend using the {#report_error} helper instead.**
      # 
      # **Note**: Does not do anything if AppSignal is not active, no
      # transaction is currently active or when the "error" is not a class
      # extended from Ruby's Exception class.
      # 
      # _@param_ `exception` — The error to add to the current transaction.
      # 
      # Manual instrumentation of set_error.
      # ```ruby
      # # Manually starting AppSignal here
      # # Manually starting a transaction here.
      # begin
      #   raise "oh no!"
      # rescue => e
      #   Appsignal.set_error(e)
      # end
      # # Manually completing the transaction here.
      # # Manually stopping AppSignal here
      # ```
      # 
      # In a Rails application
      # ```ruby
      # class SomeController < ApplicationController
      #   # The AppSignal transaction is created by our integration for you.
      #   def create
      #     # Do something that breaks
      #   rescue => e
      #     Appsignal.set_error(e)
      #   end
      # end
      # ```
      # 
      # Add more metadata to transaction
      # ```ruby
      # Appsignal.set_error(e) do
      #   Appsignal.set_namespace("my_namespace")
      #   Appsignal.set_action("my_action_name")
      #   Appsignal.add_params(:search_query => params[:search_query])
      #   Appsignal.add_tags(:key => "value")
      # end
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/ruby/instrumentation/exception-handling.html` — Exception handling guide
      def set_error: (Exception exception) ?{ (Transaction transaction) -> void } -> void

      # Report an error to AppSignal.
      # 
      # If a transaction is currently active, it will report the error on the
      # current transaction. If no transaction is active, it will report the
      # error on a new transaction.
      # 
      # If a transaction is active and the transaction already has an error
      # reported on it, it will report multiple errors, up to a maximum of 10
      # errors.
      # 
      # If a block is given to this method, the metadata set in this block will
      # only be applied to the transaction created for the given error. The
      # block will be called when the transaction is completed, which can be
      # much later than when {#report_error} is called.
      # 
      # **Note**: If AppSignal is not active, no error is reported.
      # 
      # **Note**: If the given exception argument is not an Exception subclass,
      # it will not be reported.
      # 
      # _@param_ `exception` — The error to add to the current transaction.
      # 
      # ```ruby
      # class SomeController < ApplicationController
      #   def create
      #     # Do something that breaks
      #   rescue => error
      #     Appsignal.report_error(error)
      #   end
      # end
      # ```
      # 
      # Add more metadata to transaction
      # ```ruby
      # Appsignal.report_error(error) do
      #   Appsignal.set_namespace("my_namespace")
      #   Appsignal.set_action("my_action_name")
      #   Appsignal.add_params(:search_query => params[:search_query])
      #   Appsignal.add_tags(:key => "value")
      # end
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/ruby/instrumentation/exception-handling.html` — Exception handling guide
      def report_error: (Exception exception) ?{ (Transaction transaction) -> void } -> void

      # Set a custom action name for the current transaction.
      # 
      # When using an integration such as the Rails or Sinatra AppSignal will
      # try to find the action name from the controller or endpoint for you.
      # 
      # If you want to customize the action name as it appears on AppSignal.com
      # you can use this method. This overrides the action name AppSignal
      # generates in an integration.
      # 
      # _@param_ `action`
      # 
      # in a Rails controller
      # ```ruby
      # class SomeController < ApplicationController
      #   before_action :set_appsignal_action
      # 
      #   def set_appsignal_action
      #     Appsignal.set_action("DynamicController#dynamic_method")
      #   end
      # end
      # ```
      def set_action: (String action) -> void

      # Set a custom namespace for the current transaction.
      # 
      # When using an integration such as Rails or Sidekiq AppSignal will try
      # to find a appropriate namespace for the transaction.
      # 
      # A Rails controller will be automatically put in the "http_request"
      # namespace, while a Sidekiq background job is put in the
      # "background_job" namespace.
      # 
      # Note: The "http_request" namespace gets transformed on AppSignal.com to
      # "Web" and "background_job" gets transformed to "Background".
      # 
      # If you want to customize the namespace in which transactions appear you
      # can use this method. This overrides the namespace AppSignal uses by
      # default.
      # 
      # A common request we've seen is to split the administration panel from
      # the main application.
      # 
      # _@param_ `namespace`
      # 
      # create a custom admin namespace
      # ```ruby
      # class AdminController < ApplicationController
      #   before_action :set_appsignal_namespace
      # 
      #   def set_appsignal_namespace
      #     Appsignal.set_namespace("admin")
      #   end
      # end
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/guides/namespaces.html` — Grouping with namespaces guide
      def set_namespace: (String namespace) -> void

      # Add custom data to the current transaction.
      # 
      # Add extra information about the request or background that cannot be
      # expressed in tags, like nested data structures.
      # 
      # If the root data type changes between calls of this method, the last
      # method call is stored.
      # 
      # _@param_ `data` — Custom data to add to the transaction.
      # 
      # Add Hash data
      # ```ruby
      # Appsignal.add_custom_data(:user => { :locale => "en" })
      # ```
      # 
      # Merges Hash data
      # ```ruby
      # Appsignal.add_custom_data(:abc => "def")
      # Appsignal.add_custom_data(:xyz => "...")
      # # The custom data is: { :abc => "def", :xyz => "..." }
      # ```
      # 
      # Add Array data
      # ```ruby
      # Appsignal.add_custom_data([
      #   "array with data",
      #   "other value",
      #   :options => { :verbose => true }
      # ])
      # ```
      # 
      # Merges Array data
      # ```ruby
      # Appsignal.add_custom_data([1, 2, 3])
      # Appsignal.add_custom_data([4, 5, 6])
      # # The custom data is: [1, 2, 3, 4, 5, 6]
      # ```
      # 
      # Mixing of root data types is not supported
      # ```ruby
      # Appsignal.add_custom_data(:abc => "def")
      # Appsignal.add_custom_data([1, 2, 3])
      # # The custom data is: [1, 2, 3]
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
      def add_custom_data: ((::Hash[Object, Object] | ::Array[Object]) data) -> void

      # Add tags to the current transaction.
      # 
      # Tags are extra bits of information that are added to transaction and
      # appear on sample details pages on AppSignal.com.
      # 
      # When this method is called multiple times, it will merge the tags.
      # 
      # _@param_ `tags` — Collection of tags to add to the transaction.
      # 
      # ```ruby
      # Appsignal.add_tags(:locale => "en", :user_id => 1)
      # Appsignal.add_tags("locale" => "en")
      # Appsignal.add_tags("user_id" => 1)
      # ```
      # 
      # Nested hashes are not supported
      # ```ruby
      # # Bad
      # Appsignal.add_tags(:user => { :locale => "en" })
      # ```
      # 
      # in a Rails controller
      # ```ruby
      # class SomeController < ApplicationController
      #   before_action :add_appsignal_tags
      # 
      #   def add_appsignal_tags
      #     Appsignal.add_tags(:locale => I18n.locale)
      #   end
      # end
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/ruby/instrumentation/tagging.html` — Tagging guide
      def add_tags: (?::Hash[Object, Object] tags) -> void

      # Add parameters to the current transaction.
      # 
      # Parameters are automatically added by most of our integrations. It
      # should not be necessary to call this method unless you want to report
      # different parameters.
      # 
      # To filter parameters, see our parameter filtering guide.
      # 
      # When both the `params` argument and a block is given to this method,
      # the block is leading and the argument will _not_ be used.
      # 
      # _@param_ `params` — The parameters to add to the transaction.
      # 
      # Add parameters
      # ```ruby
      # Appsignal.add_params("param1" => "value1")
      # # The parameters include: { "param1" => "value1" }
      # ```
      # 
      # Calling `add_params` multiple times will merge the values
      # ```ruby
      # Appsignal.add_params("param1" => "value1")
      # Appsignal.add_params("param2" => "value2")
      # # The parameters include:
      # # { "param1" => "value1", "param2" => "value2" }
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
      # 
      # _@see_ `https://docs.appsignal.com/guides/filter-data/filter-parameters.html` — Parameter filtering guide
      def add_params: (?::Hash[untyped, untyped]? params) -> void

      # Mark the parameters sample data to be set as an empty value.
      # 
      # Use this helper to unset request parameters / background job arguments
      # and not report any for this transaction.
      # 
      # If parameters would normally be added by AppSignal instrumentations of
      # libraries, these parameters will not be added to the Transaction.
      # 
      # Calling {#add_params} after this helper will add new parameters to the
      # transaction.
      # 
      # _@see_ `Transaction#set_empty_params!`
      # 
      # _@see_ `Transaction#set_params_if_nil`
      def set_empty_params!: () -> void

      # Add session data to the current transaction.
      # 
      # Session data is automatically added by most of our integrations. It
      # should not be necessary to call this method unless you want to report
      # different session data.
      # 
      # To filter session data, see our session data filtering guide.
      # 
      # When both the `session_data` argument and a block is given to this
      # method, the bock is leading and the argument will _not_ be used.
      # 
      # _@param_ `session_data` — The session data to add to the transaction.
      # 
      # Add session data
      # ```ruby
      # Appsignal.add_session_data("session" => "data")
      # # The session data will include:
      # # { "session" => "data" }
      # ```
      # 
      # Calling `add_session_data` multiple times merge the values
      # ```ruby
      # Appsignal.add_session_data("session" => "data")
      # Appsignal.add_session_data("other" => "value")
      # # The session data will include:
      # # { "session" => "data", "other" => "value" }
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
      # 
      # _@see_ `https://docs.appsignal.com/guides/filter-data/filter-session-data.html` — Session data filtering guide
      def add_session_data: (?::Hash[untyped, untyped]? session_data) -> void

      # Add request headers to the current transaction.
      # 
      # Request headers are automatically added by most of our integrations. It
      # should not be necessary to call this method unless you want to also
      # report different request headers.
      # 
      # To filter request headers, see our request header filtering guide.
      # 
      # When both the `request_headers` argument and a block is given to this
      # method, the block is leading and the argument will _not_ be used.
      # 
      # _@param_ `headers` — The request headers to add to the transaction.
      # 
      # Add request headers
      # ```ruby
      # Appsignal.add_headers("PATH_INFO" => "/some-path")
      # # The request headers will include:
      # # { "PATH_INFO" => "/some-path" }
      # ```
      # 
      # Calling `add_headers` multiple times merge the values
      # ```ruby
      # Appsignal.add_headers("PATH_INFO" => "/some-path")
      # Appsignal.add_headers("HTTP_USER_AGENT" => "Firefox")
      # # The request headers will include:
      # # { "PATH_INFO" => "/some-path", "HTTP_USER_AGENT" => "Firefox" }
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/guides/custom-data/sample-data.html` — Sample data guide
      # 
      # _@see_ `https://docs.appsignal.com/guides/filter-data/filter-headers.html` — Request headers filtering guide
      def add_headers: (?::Hash[untyped, untyped]? headers) -> void

      # Add breadcrumbs to the transaction.
      # 
      # Breadcrumbs can be used to trace what path a user has taken
      # before encountering an error.
      # 
      # Only the last 20 added breadcrumbs will be saved.
      # 
      # _@param_ `category` — category of breadcrumb e.g. "UI", "Network", "Navigation", "Console".
      # 
      # _@param_ `action` — name of breadcrumb e.g "The user clicked a button", "HTTP 500 from http://blablabla.com"
      # 
      # ```ruby
      # Appsignal.add_breadcrumb(
      #   "Navigation",
      #   "http://blablabla.com",
      #   "",
      #   { :response => 200 },
      #   Time.now.utc
      # )
      # Appsignal.add_breadcrumb(
      #   "Network",
      #   "[GET] http://blablabla.com",
      #   "",
      #   { :response => 500 }
      # )
      # Appsignal.add_breadcrumb(
      #   "UI",
      #   "closed modal(change_password)",
      #   "User closed modal without actions"
      # )
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/ruby/instrumentation/breadcrumbs.html` — Breadcrumb reference
      def add_breadcrumb: (
                            String category,
                            String action,
                            ?::Hash[untyped, untyped] message,
                            ?::Hash[untyped, untyped] metadata,
                            ?::Hash[untyped, untyped] time
                          ) -> void

      # Instrument helper for AppSignal.
      # 
      # For more help, read our custom instrumentation guide, listed under "See
      # also".
      # 
      # _@param_ `name` — Name of the instrumented event. Read our event naming guide listed under "See also".
      # 
      # _@param_ `title` — Human readable name of the event.
      # 
      # _@param_ `body` — Value of importance for the event, such as the server against an API call is made.
      # 
      # _@param_ `body_format` — Enum for the type of event that is instrumented. Accepted values are {EventFormatter::DEFAULT} and {EventFormatter::SQL_BODY_FORMAT}, but we recommend you use {.instrument_sql} instead of {EventFormatter::SQL_BODY_FORMAT}.
      # 
      # _@return_ — Returns the block's return value.
      # 
      # Simple instrumentation
      # ```ruby
      # Appsignal.instrument("fetch.issue_fetcher") do
      #   # To be instrumented code
      # end
      # ```
      # 
      # Instrumentation with title and body
      # ```ruby
      # Appsignal.instrument(
      #   "fetch.issue_fetcher",
      #   "Fetching issue",
      #   "GitHub API"
      # ) do
      #   # To be instrumented code
      # end
      # ```
      # 
      # _@see_ `.instrument_sql`
      # 
      # _@see_ `https://docs.appsignal.com/ruby/instrumentation/instrumentation.html` — AppSignal custom instrumentation guide
      # 
      # _@see_ `https://docs.appsignal.com/api/event-names.html` — AppSignal event naming guide
      def instrument: (
                        String name,
                        ?String? title,
                        ?String? body,
                        ?Integer body_format
                      ) -> Object

      # Instrumentation helper for SQL queries.
      # 
      # This helper filters out values from SQL queries so you don't have to.
      # 
      # _@param_ `name` — Name of the instrumented event. Read our event naming guide listed under "See also".
      # 
      # _@param_ `title` — Human readable name of the event.
      # 
      # _@param_ `body` — SQL query that's being executed.
      # 
      # _@return_ — Returns the block's return value.
      # 
      # SQL query instrumentation
      # ```ruby
      # body = "SELECT * FROM ..."
      # Appsignal.instrument_sql("perform.query", nil, body) do
      #   # To be instrumented code
      # end
      # ```
      # 
      # SQL query instrumentation
      # ```ruby
      # body = "WHERE email = 'foo@..'"
      # Appsignal.instrument_sql("perform.query", nil, body) do
      #   # query value will replace 'foo..' with a question mark `?`.
      # end
      # ```
      # 
      # _@see_ `.instrument`
      # 
      # _@see_ `https://docs.appsignal.com/ruby/instrumentation/instrumentation.html` — AppSignal custom instrumentation guide
      # 
      # _@see_ `https://docs.appsignal.com/api/event-names.html` — AppSignal event naming guide
      def instrument_sql: (String name, ?String? title, ?String? body) -> Object

      # Convenience method for ignoring instrumentation events in a block of
      # code.
      # 
      # - This helper ignores events, like those created
      #   `Appsignal.instrument`, within this block.
      #   This includes custom instrumentation and events recorded by AppSignal
      #   integrations for requests, database queries, view rendering, etc.
      # - The time spent in the block is still reported on the transaction.
      # - Errors and metrics are reported from within this block.
      # 
      # _@return_ — Returns the return value of the block.
      # 
      # ```ruby
      # Appsignal.instrument "my_event.my_group" do
      #   # Complex code here
      # end
      # Appsignal.ignore_instrumentation_events do
      #   Appsignal.instrument "my_ignored_event.my_ignored_group" do
      #     # Complex code here
      #   end
      # end
      # 
      # # Only the "my_event.my_group" instrumentation event is reported.
      # ```
      # 
      # _@see_ `https://docs.appsignal.com/ruby/instrumentation/ignore-instrumentation.html` — Ignore instrumentation guide
      def ignore_instrumentation_events: () -> Object
    end
  end

  class InternalError < StandardError
  end

  class NotStartedError < Appsignal::InternalError
    def message: () -> String
  end
end

# Extensions to Object for AppSignal method instrumentation.
# 
# @see https://docs.appsignal.com/ruby/instrumentation/method-instrumentation.html
#   Method instrumentation documentation.
class Object < BasicObject
  # Instruments a class method with AppSignal monitoring.
  # 
  # _@param_ `method_name` — The name of the class method to instrument.
  # 
  # _@param_ `options` — Options for instrumentation.
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/method-instrumentation.html` — Method instrumentation documentation.
  def self.appsignal_instrument_class_method: (Symbol method_name, ?::Hash[untyped, untyped] options) -> Symbol

  # Instruments an instance method with AppSignal monitoring.
  # 
  # _@param_ `method_name` — The name of the instance method to instrument.
  # 
  # _@param_ `options` — Options for instrumentation.
  # 
  # _@see_ `https://docs.appsignal.com/ruby/instrumentation/method-instrumentation.html` — Method instrumentation documentation.
  def self.appsignal_instrument_method: (Symbol method_name, ?::Hash[untyped, untyped] options) -> Symbol
end